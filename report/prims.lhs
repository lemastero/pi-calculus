%include polycode.fmt

\subsubsection{List, Pair and Number Functions}

These are the basic term manipulation functions. Those familiar with Haskell should find these very familiar.

>add(num1, num2) => (num1 + num2)

Returns the sum of two given numbers.

>fst(pair(a,b)) => a

When given a pair of terms, this returns the first element of the pair.

>snd(pair(a,b)) => b

When given a pair of terms, this returns the second element of the pair.

>cons(x ,list(a,b..)) => list(x,a,b..)

Given a term and a list of terms, we return a list with the term placed at the front (N.B. lists are heterogeneous in our implementation).

>head(list(a,b..)) => a

Returns the first element of a given list.

>tail(list(a,b..)) => list(b..)

Discards the first element of the list, and returns the remaining elements.

>append(list(a..),list(b..)) => list(a..,b..)

Appends list b to the end of list a


\subsubsection{HTTP Data Functions}

>httpReq(uri, headers(..), method) => request : HttpRequest

When given a uri, which can either be generated by the $uri$ function below, or given as a string (e.g. "www.google.com/index.html"), a list of headers, which again can be generated using $headers$ or by passing a raw $list$ of headers, and a request method (at the moment this is limited to $httpGet()$, $httpPost()$, $httpHead()$ corresponding to GET, POST and HEAD requests) will generate an HTTP request.

>httpResp(responseCode, reason, headers(..), body) => response : HttpResponse

When given a response code, (as a number e.g. 404) list of headers, a reason, (as a string e.g. "Not Found"), a list of headers, which can be generated using $headers$ or by passing a raw $list$ of headers, and a reponse body (as a string e.g. "$<$HTML$>$..$<$/HTML$>$")

>headers(h1,h2..) => list(h1,h2..)

$headers$ is simply a synonym for list, but is used for clarity when generating HTTP Data.

>header(name,value) => header

When given a name and a value, both strings, $header$ generates a header. 
Internally this is simply appending the two strings with a colon inbetween the two. (i.e. $header("Content-Length","348") =>$ "Content-Length: 348").

>cookies(c1,c2..) => list(c1,c2..)

$cookies$ is also a synonym for list, but is again used for clarity when generating lists of headers.

>getHeaders(httpData) => headers(..)

When given a piece of HTTP data (either generated by the above $httpReq$ and $httpResp$, or received from an external source), return the of headers of the data.

>insertHeader(header,httpData) => httpData 
>insertHeader(header,headers(h1,h2..)) => headers(header,h1,h2..))  

This function is given a header (either generated by $header$ or given as a raw string) and either a piece of HTTP data or a list of headers, and returns the data or the list of headers with the header inserted.

>getHeader(headerName, httpData) =>  headerVal

When given a header name, such as "Content-Length", and a piece of HTTP data, returns the associated header's value.
If there is no such header in the data's headers then it returns an error.

>getCookie(httpData) => cookie

When given a piece of HTTP data returns the cookie from that data.

>setCookie(cookie, httpData) => httpData

When given a cookie and a piece of HTTP data returns the data with the cookie inserted.

>uri(host,resource) => uri

When given a host (as a string, e.g. "www.google.com"), and a resource (again a string, e.g. "index.html") returns a uri pointing to that location. 
Internally this appends the two strings with "/" inbetween (i.e. $uri("www.google.com","index.html") =>$ "www.google.com/index.html").

>rspCode(response) => code

Given an HTTP response returns the response code from this response.


Several of the functions which retrieve data from lists and HTTP data can be achieved using pattern matching, which is explained in Section \ref{sec:patterns}, but are provided for convenience.

\subsubsection{Cryptographic Functions}

The following functions are used for manipulating terms cryptographically. Currently, many of these functions are barebones implementations, and are not cryptographically sound. The reasons for this is as follows, in \cite{rs13} it is stated that the behaviour of these functions is "captured by the smallest equational theory satisfying:"

>sdec(x, senc(x, y))          == y
>adec(x, aenc(pk(x), y))      == y
>getmsg(sign(x, y))           == y
>checksign(pk(x), sign(x, y)) == true

meaning that as long as these equalities hold true, then details of the implementation are unimportant. Many of these encoding and decoding cryptographic funtions require random seeding and other stateful operations. Ordinarily, this would not be an issue. However, Haskell is a pure language, and so stateful computations are not the norm, and would require one of two things to acheive: 

\begin{enumerate}
    \item We could place all the operations of the primitives module into the $IOThrowsError a$ Monad which is an instance of the $MonadIO$ typeclass \cite{hack:monadIO} meaning that we can use $liftIO$ to expose the $IO$ monad and perform stateful computations. This would require lifting all of the $ThrowsError a$ monadic code, which seems wasteful considering that it is only these primitive functions that would require lifting. 
    \item We use the $System.IO.Unsafe$ \cite{hack:unsafeIO} module to perform stateful computations outside of the $IO$ Monad. However, this has potentially unpredictable results, and it feels wrong to "cheat" the purity of the language.
\end{enumerate}

As neither of these are particularly appealing, we chose to make our implementation a basic one. In Section \ref{sec:extension} we will discuss in more detail how we would handle this going future.

>hash(msg) => hash

Given a message, which is either a plain string or a string of bytes, returns a hash of the message as a string of bytes.
Internally, we hash using the MD5 scheme, but this choice was fairly arbitrary.

>mac(key,msg) => mac

Given a key, as a string of bytes, and a message, again either a plain string or string of bytes, returns a MAC of the message.
Internally, the hashing scheme is MD5 also.

>pk(k) => pk

Given a private key, generates an associated public key.

>sign(k,msg) => signed

Given a private key and a message, signs the message using the key.

>getmsg(sign(k,msg)) => msg

Given a signed message, returns the message.

>checksign(pk(k),sign(k,msg)) => true
>checksign(pk(k),sign(_,msg)) => false

Checks whether a message was signed using a given public key.

>senc(k,msg) => encodedMsg
>sdec(k,senc(k,msg)) => msg

Symmetrically encode and decode a message given a key.

>aenc(pk(k),msg) => encodedMsg
>adec(k,aenc(pk(k),msg)) => msg

Asymmetrically encode and decode a message with a public key / private key system.
