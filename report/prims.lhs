%include polycode.fmt

\subsubsection{List, Pair and Number Functions}

These are the basic term manipulation functions. Those familiar with Haskell should find these very familiar.
\begin{code}
add(num1, num2) => (num1 + num2)
\end{code}
Returns the sum of two given numbers.

\begin{code}
fst(pair(a,b)) => a
\end{code}

When given a pair of terms, this returns the first element of the pair.

\begin{code}
snd(pair(a,b)) => b
\end{code}

When given a pair of terms, this returns the second element of the pair.

\begin{code}
cons(x ,list(a,b..)) => list(x,a,b..)
\end{code}

Given a term and a list of terms, we return a list with the term placed at the front (N.B. lists are heterogeneous in our implementation).

\begin{code}
head(list(a,b..)) => a
\end{code}

Returns the first element of a given list.

\begin{code}
tail(list(a,b..)) => list(b..)
\end{code}

Discards the first element of the list, and returns the remaining elements.

\begin{code}
append(list(a..),list(b..)) => list(a..,b..)
\end{code}

Appends list b to the end of list a


\subsubsection{HTTP Data Functions}

\begin{code}
httpReq(uri, headers(..), method) => request : HttpRequest
\end{code}

When given a uri, which can either be generated by the $uri$ function below, or given as a string (e.g. "www.google.com/index.html"), a list of headers, which again can be generated using $headers$ or by passing a raw $list$ of headers, and a request method (at the moment this is limited to $httpGet()$, $httpPost()$, $httpHead()$ corresponding to GET, POST and HEAD requests) will generate an HTTP request.

\begin{code}
httpResp(responseCode, reason, headers(..), body) => response : HttpResponse
\end{code}

When given a response code, (as a number e.g. 404) list of headers, a reason, (as a string e.g. "Not Found"), a list of headers, which can be generated using $headers$ or by passing a raw $list$ of headers, and a reponse body (as a string e.g. "$<$HTML$>$..$<$/HTML$>$")

\begin{code}
headers(h1,h2..) => list(h1,h2..)
\end{code}

$headers$ is simply a synonym for list, but is used for clarity when generating HTTP Data.

\begin{code}
header(name,value) => header
\end{code}

When given a name and a value, both strings, $header$ generates a header. 
Internally this is simply appending the two strings with a colon inbetween the two. (i.e. $header("Content-Length","348") =>$ "Content-Length: 348").

\begin{code}
cookies(c1,c2..) => list(c1,c2..)
\end{code}

$cookies$ is also a synonym for list, but is again used for clarity when generating lists of headers.

\begin{code}
getHeaders(httpData) => headers(..)
\end{code}

When given a piece of HTTP data (either generated by the above $httpReq$ and $httpResp$, or received from an external source), return the of headers of the data.

\begin{code}
insertHeader(header,httpData) => httpData 
insertHeader(header,headers(h1,h2..)) => headers(header,h1,h2..))  
\end{code}

This function is given a header (either generated by $header$ or given as a raw string) and either a piece of HTTP data or a list of headers, and returns the data or the list of headers with the header inserted.

\begin{code}
getHeader(headerName, httpData) =>  headerVal
\end{code}

When given a header name, such as "Content-Length", and a piece of HTTP data, returns the associated header's value.
If there is no such header in the data's headers then it returns an error.

\begin{code}
getCookie(httpData) => cookie
\end{code}

When given a piece of HTTP data returns the cookie from that data.

\begin{code}
setCookie(cookie, httpData) => httpData
\end{code}

When given a cookie and a piece of HTTP data returns the data with the cookie inserted.

\begin{code}
uri(host,resource) => uri
\end{code}

When given a host (as a string, e.g. "www.google.com"), and a resource (again a string, e.g. "index.html") returns a uri pointing to that location. 
Internally this appends the two strings with "/" inbetween (i.e. $uri("www.google.com","index.html") =>$ "www.google.com/index.html").

\begin{code}
rspCode(response) => code
\end{code}

Given an HTTP response returns the response code from this response.


Several of the functions which retrieve data from lists and HTTP data can be achieved using pattern matching, which is explained in Section \ref{sec:patterns}, but are provided for convenience.

\subsubsection{Cryptographic Functions}

The following functions are used for manipulating terms cryptographically. Currently, many of these functions are barebones implementations, and are not cryptographically sound. The reasons for this is as follows, in \cite{rs13} it is stated that the behaviour of these functions is "captured by the smallest equational theory satisfying:"

\begin{code}
sdec(x, senc(x, y))          == y
adec(x, aenc(pk(x), y))      == y
getmsg(sign(x, y))           == y
checksign(pk(x), sign(x, y)) == true
\end{code}

meaning that as long as these equalities hold true, then details of the implementation are unimportant. Many of these encoding and decoding cryptographic funtions require random seeding and other stateful operations. Ordinarily, this would not be an issue. However, Haskell is a pure language, and so stateful computations are not the norm, and would require one of two things to acheive: 

\begin{enumerate}
    \item We could place all the operations of the primitives module into the $IOThrowsError a$ Monad which is an instance of the $MonadIO$ typeclass \cite{hack:monadIO} meaning that we can use $liftIO$ to expose the $IO$ monad and perform stateful computations. This would require lifting all of the $ThrowsError a$ monadic code, which seems wasteful considering that it is only these primitive functions that would require lifting. 
    \item We use the $System.IO.Unsafe$ \cite{hack:unsafeIO} module to perform stateful computations outside of the $IO$ Monad. However, this has potentially unpredictable results, and it feels wrong to "cheat" the purity of the language.
\end{enumerate}

As neither of these are particularly appealing, we chose to make our implementation a basic one. In Section \ref{sec:extension} we will discuss in more detail how we would handle this going future.

\begin{code}
hash(msg) => hash
\end{code}

Given a message, which is either a plain string or a string of bytes, returns a hash of the message as a string of bytes.
Internally, we hash using the MD5 scheme, but this choice was fairly arbitrary.

\begin{code}
mac(key,msg) => mac
\end{code}

Given a key, as a string of bytes, and a message, again either a plain string or string of bytes, returns a MAC of the message.
Internally, the hashing scheme is MD5 also.

\begin{code}
pk(k) => pk
\end{code}

Given a private key, generates an associated public key.

\begin{code}
sign(k,msg) => signed
\end{code}

Given a private key and a message, signs the message using the key.

\begin{code}
getmsg(sign(k,msg)) => msg
\end{code}

Given a signed message, returns the message.

\begin{code}
checksign(pk(k),sign(k,msg)) => true
checksign(pk(k),sign(_,msg)) => false
\end{code}

Checks whether a message was signed using a given public key.

\begin{code}
senc(k,msg) => encodedMsg
sdec(k,senc(k,msg)) => msg
\end{code}

Symmetrically encode and decode a message given a key.

\begin{code}
aenc(pk(k),msg) => encodedMsg
adec(k,aenc(pk(k),msg)) => msg
\end{code}

Asymmetrically encode and decode a message with a public key / private key system.
