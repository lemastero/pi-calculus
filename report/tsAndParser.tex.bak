\section{Types and Parsing}
\label{sec:types}
In this section, we will describe the data structures we use to represent the the processes, channels and data in our program. We will also briefly cover the way in which we used Parsec to parse our input and create build those structures.

\subsection{Types}
\label{subsec:types}

\subsubsection{Processes}

\begin{minted}[linenos,frame=lines]{hs}
data PiProcess = Null
               | In   Term Term
               | Out  Term Term
               | New  Term
               | PiProcess `Seq` PiProcess 
               | Conc [PiProcess]          
               | Replicate PiProcess       
               | Let Term Value (Maybe PiProcess)
               | If Condition PiProcess PiProcess
               | Atom Term
                 deriving (Eq)

instance Show PiProcess where show = showPi
\begin{minted}[linenos,frame=lines]{hs}
data Condition = Term `Equals` Term deriving (Eq)

instance Show Condition where show = showCond
\end{minted}

\subsubsubsection{HTTP Data}
\end{minted}
\subsubsection{Terms}

\begin{minted}[linenos,frame=lines]{hs}
data Term = TVar Name (Maybe Type)
          | TStr String
          | TNum Integer
          | TBool Bool
          | TPair (Term, Term)
          | TList [Term]
          | TBS ByteString
          | TData HttpData
          | TFun Name [Term]
            deriving (Eq)
instance Show Term where show = showTerm

type Name = String
\end{minted}

\subsubsubsection{HTTP Data}

\begin{minted}[linenos,frame=lines]{hs}
data HttpData = Resp (Response String)
              | Req  (Request String)

instance Show HttpData where show = showHttpData
instance Eq HttpData where (==) = eqHttpData
\end{minted}

\begin{minted}[linenos,frame=lines]{hs}
instance HasHeaders HttpData where
    getHeaders (Resp r) = getHeaders r
    getHeaders (Req r)  = getHeaders r
    setHeaders (Resp r) = Resp . setHeaders r
    setHeaders (Req r)  = Req . setHeaders r
\end{minted}

\subsubsection{Channels}
\begin{minted}[linenos,frame=lines]{hs}
data Channel = Channel {
               send         :: String -> IO ()
             , receive      :: IO String
             , extra        :: [String]
             }
\end{minted}
\subsubsection{Values}
\begin{minted}[linenos,frame=lines]{hs}
data Value = Proc PiProcess 
           | Term Term
           | Chan Channel
           | PrimitiveFunc TermFun
           | Func {params :: [String] , body :: Value, closure :: Env}

instance Show Value where show = showVal
instance Eq Value where (==) = eqvVal
\end{minted}
\begin{minted}[linenos,frame=lines]{hs}
showValue :: Value -> String
showValue (Proc p)  = show p
showValue (Term t)  = show t
showValue (Chan c)  = show (convert c)
    where 
        convert ch = TFun "<chan>" (map TStr ex) 
            where ex = extra ch
showValue (PrimitiveFunc _)  = "<primitive>" 
showValue (Func {})          = "<user function>"  
\end{minted}
\subsubsection{Error Handling}
\begin{minted}[linenos,frame=lines]{hs}
data PiError = NumArgs Name Integer [Value]
             | TypeMismatch String [Value]
             | Parser ParseError
             | UnboundVar String String
             | NotTerm Name Value
             | NotFunction String String
             | NotChannel String
             | NotProcess String
             | PatternMatch Term Term
             | Default String

instance Show PiError where show = showError
\end{minted}



\begin{description}
    \item[$Null$] Represents the null, or terminal process
    \item[$In$] Represents a process receiving data in on a channel
    \item[$Out$] Represents a process sending data out on a channel
    \item[$New$] Represents the reservation of a variable name 
    \item[$Seq$] Represents the sequential composition of two processes
    \item[$Conc$] Represents the concurrent composition of a list of processes
    \item[$Replicate$] Represents the infinite concurrent composition of a process with itself
    \item[$Let$] Represents the 
\end{desription}

\subsection{Parser}
\label{subsec:parser}
