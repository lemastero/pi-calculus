\section{Types and Parsing}
\label{sec:types}
In this section, we will describe the data structures we use to represent the the processes, channels and data in our program. We will also briefly cover the way in which we used Parsec to parse our input and create build those structures.

\subsection{Types}
\label{subsec:types}

\subsubsection{Terms}

The most fundamental data type in our implementation is the $Term$. Terms are used to represent data, variables and functions.

\begin{minted}[linenos,frame=lines]{hs}
data Term = TStr String        
          | TNum Integer
          | TBool Bool
          | TBS ByteString
          | TData HttpData
          | TPair (Term, Term)
          | TList [Term]
          | TVar Name (Maybe Type)
          | TFun Name [Term]
            deriving (Eq)
instance Show Term where show = showTerm

type Name = String
\end{minted}
We can see that terms derive Eq, meaning that two terms with the same contents, when compared with $==$ will return $True$. We derive our own instance of Show, which appropriately unwraps each of the above. $Name$ is simple a type synonym for $String$.

TStr, TNum, TBool, and TBS are just simple wrappers for their respective types (String, Integer, Bool and ByteString), to allow us to manipulate them together in Haskell's type system.

TData is a wrapper for HttpData, which is explained in \ref{para:httpdata}

The next few are slightly more complicated. TPair is a wrapper around Haskell's own Tuple type, which can recursively hold two Terms. TList is a wrapper around Haskell's List type, which holds a list of Terms.

TVar is used as a variable. It is constructed using a Name (String) and a Maybe Type. Maybe is a data type in the Haskell Prelude that allows either for a value (using the constructor Just, e.g. Just 1) or no value (using the Nothing constructor). This means that we allow a variable to have no type, but it is possible to construct a variable with a type. Type itself only has two constructors: 

\paragraph{Type}
\begin{minted}[linenos,frame=lines]{hs}
data Type = HttpRequest
          | HttpResponse
          deriving (Eq, Read, Show)
\end{minted}
These are currently only used when receiving data in from an external channel, which is explained in section \ref{sec:channels}

Finally, a TFun is constructed with a Name and a list of Terms. They represent a function (either over terms or over processes).\footnote{It would have been possible to do away with both TPair and TList, and simply had a special case of TFun (which is in fact how they are constructed in the Parser) but we found that this quickly became tedious, so we created these special types which made manipulating them easier.}

\paragraph{HttpData}
\label{para:httpdata}

HttpData is itself a wrapper around the $Response$ and $Request$ type constructors from the Network.HTTP.Base \cite{hack:httpBase} module. Again, we began our implementation with these being special cases of TFun, however we found ourselves converting to and from Responses and Requests that we cut out the middle TFun and added them to our Term structure.
\begin{minted}[linenos,frame=lines]{hs}
data HttpData = Resp (Response String)
              | Req  (Request String)

instance Show HttpData where show = showHttpData
instance Eq HttpData where (==) = eqHttpData
\end{minted}

We created our own instances of Show and Eq in order to unwrap the responses/requests from our constructors. 

We also had to unwrap responses and requests from our constructors when creating an instance of HasHeaders \cite{hack:headers} which is a typeclass used in many header manipulation functions of the HTTP module
\begin{minted}[linenos,frame=lines]{hs}
instance HasHeaders HttpData where
    getHeaders (Resp r) = getHeaders r
    getHeaders (Req r)  = getHeaders r
    setHeaders (Resp r) = Resp . setHeaders r
    setHeaders (Req r)  = Req . setHeaders r
\end{minted}
\subsubsection{Processes}

Processes are modelled with the $PiProcess$ data type.\footnote{N.B. This is merely how processes are modelled, not how they are actually implemented, this is covered in section \ref{sec:processes}}

\begin{minted}[linenos,frame=lines]{hs}
data PiProcess = Null
               | In   Term Term
               | Out  Term Term
               | New  Term
               | PiProcess `Seq` PiProcess 
               | Conc [PiProcess]          
               | Replicate PiProcess       
               | Let Term Value (Maybe PiProcess)
               | If Condition PiProcess PiProcess
               | Atom Term
                 deriving (Eq)

instance Show PiProcess where show = showPi
\end{minted}
This data type derives Eq and we defined our own Show instance (the output of which is identical to our defined syntax for the language). 

The constructors are described as follows:

\begin{description}
    \item[$Null$] Represents the null, or terminal process
    \item[$In$] Represents a process receiving data in on a channel. The first term should be either a TFun which evaluates to a channel, or a variable pointing to one, and the second should be a variable
    \item[$Out$] Represents a process sending data out on a channel. The first term should evaluate to a channel, as in In, and the second can be a term of any type
    \item[$New$] Represents the reservation of a variable name 
    \item[$Seq$] Represents the sequential composition of two processes
    \item[$Conc$] Represents the concurrent composition of a list of processes
    \item[$Replicate$] Represents the infinite concurrent composition of a process with itself
    \item[$Let$] Represents the assignment of a variable, or function to a value or function body. The Maybe PiProcess here represents the possibility either of locally assigning the variable in the process found within the Just constructor, or globally assigning the variable if the Maybe is Nothing.
    \item[$If$] Represents the conditional execution of either the first process if the Condition is true, or the second process if it is false. Conditions are explained in section \ref{para:condition}
    \item[$Atom$] Represents a reference to a process, either as a TFun or a TVar.\footnote{These must evaluate to a PiProcess, or else an error will occur}
\end{desription}

The Atom constructor was added to the language in order to allow calling process functions. We encountered a problem when we were implementing the language in that we had the ability to define process functions and references to processes using let, but had no way of calling them within our PiProcess type at the time. Our solution was to add this constructor, which is used by prepending "$&$" to a bare Term. See section \ref{eg:recursivecall} for an example of its use.
\paragraph{Condition}
\label{para:condition}

Conditions are modelled with a very simple data type. They currently only allow a single constructor:

\begin{minted}[linenos,frame=lines]{hs}
data Condition = Term `Equals` Term deriving (Eq)

instance Show Condition where show = showCond
\end{minted}

We had thought that we would need to extend this, however we found that no other conditional types were needed. There is still the possibility to provide this extension later.

\subsubsection{Channels}

A Channel is modelled as follows:

\begin{minted}[linenos,frame=lines]{hs}
data Channel = Channel {
               send         :: String -> IO ()
             , receive      :: IO String
             , extra        :: [String]
             }
\end{minted}

We have a single constructor, Channel, which takes two functions and a list of strings:
\begin{description}
    \item[$send$] Any function which takes a string and returns IO (). It is of course intended that this sends this string to a destination, although what this destination is and how this is achieved is not specified here.
    \item[$receive$] Any function which produces a String in the IO monad. Again, this function is intended to retrieve this string from some source, but once again this is not specified here.
    \item[$extra$] Contains any extra data that might be associated with the channel. This is used in the serialisation of Channels which we explain in more detail in section \ref{sec:serialisingChannels}.
\end{description}

The actual implementation of a Channel is left deliberately vague, to allow for many different types of channels to be built. In section \ref{sec:channels} we give our implementations.

\subsubsection{Values}

Values are the data type we use to represent all of our types in the single environment we pass around our evaluation strategy (see section \ref{sec:main})

\begin{minted}[linenos,frame=lines]{hs}
data Value = Proc PiProcess 
           | Term Term
           | Chan Channel
           | PrimitiveFunc TermFun
           | Func {params :: [String] , body :: Value, closure :: Env}

instance Show Value where show = showVal
instance Eq Value where (==) = eqvVal
\end{minted}

The first three are simply wrappers around the data types we have described so far.
PrimitiveFunc models a primitive Term function, and contains a TermFun, defined in section \ref{sec:termfun}
Func models a user defined function, which holds a list of parameters (as a list of Strings), a function body (itself a Value), and a closure within which the function is evaluated (as an Env, the type of which is described in section \ref{sec:environment}). The implementation of these two will be explained in section \ref{sec:main}

We define our own instances of Show and Eq

\begin{minted}[linenos,frame=lines]{hs}
showValue :: Value -> String
showValue (Proc p)  = show p
showValue (Term t)  = show t
showValue (Chan c)  = show (convert c)
    where 
        convert ch = TFun "<chan>" (map TStr ex) 
            where ex = extra ch
showValue (PrimitiveFunc _)  = "<primitive>" 
showValue (Func {})          = "<user function>"  

eqvVal :: Value -> Value -> Bool
eqvVal (Proc p1)  (Proc p2) = p1 == p2
eqvVal (Term t1)  (Term t2) = t1 == t2
eqvVal _ _ = False
\end{minted}

Our show implementation is uninteresting, besides for showing Channels. This is essentially a hack for serialising channels\footnote{When we receive a term in a phi process, we check to see whether it has the special name "<chan>" and then try to build a channel from the data in the arguments, we go into this in more detail in section\ref{sec:serialisingChannels}}

\subsubsection{Environment}
\label{sec:environment}


\begin{minted}[linenos,frame=lines]{hs}
type Env = IORef (Map String Value)
\end{minted}

We model our environment as an IO Reference to a Map of Strings to Values. An IO Reference, or IORef \cite{hack:ioref} can be thought of as a pointer to some mutable state in the IO monad. Our environment will obviously change through our implementation, and so we need to model this mutability. We chose IORefs over other possible mutability models because they are fast, and we are already operating within the IO monad for a lot of our evaluation strategy.

\subsubsection{Error Handling}

Finally, we have our data type representing errors in our evaluation and/or parsing.

\begin{minted}[linenos,frame=lines]{hs}
data PiError = NumArgs Name Integer [Value]
             | TypeMismatch String [Value]
             | Parser ParseError
             | UnboundVar String String
             | NotTerm Name Value
             | NotFunction String String
             | NotChannel String
             | NotProcess String
             | PatternMatch Term Term
             | Default String

instance Show PiError where show = showError
\end{minted}

The purpose of these errors is fairly clear from the names of their constructors.

We represent functions which can throw errors in two ways. They can have two return types:

\begin{description}
    \item[ThrowsError a] meaning they return either a PiError (which is raised using throwError from the Control.Monad.Error module \cite{hack:monadError}) or return something of type a (using return, which lifts a value into the Either monad \cite{hack:either})
    \item[IOThrowsError a] meaning they can return a PiError or a something of type a, but can also perform operations in the IO monad, internally using the ExceptT monad \cite{hack:monadExcept} which is an instance of the MonadIO typeclass \cite{hack:monadIO}.
\end{description}

The type synonyms for these are as follows

\begin{minted}[linenos,frame=lines]{hs}
type ThrowsError a   = Either  PiError a
type IOThrowsError a = ExceptT PiError IO a
\end{minted}

We also have a type synonym for TermFun s

\label{sec:termfun}
\begin{minted}[linenos,frame=lines]{hs}
type TermFun = [Term] -> ThrowsError Term
\end{minted}

So a TermFun is a function which takes a list of Terms and can either throw an error or return a Term


\subsection{Parser}
\label{subsec:parser}
