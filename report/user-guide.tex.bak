\section{Program Use}

\subsection{Installation}

The source is available on Hackage, and can be installed using cabal:

\begin{code}
    cabal update
    cabal install pi-calculus
\end{code}

Alternatively you can clone the source and build using cabal:

\begin{code}
    git clone git@github:renzyq19/pi-calculus
    cd pi-calculus/pi
    cabal install
\end{code}

\subsection{Running}

To run the interpreter, we can either enter the Read Eval Print Loop (REPL) by entering typing phi at the command line:
\begin{code}
    $ phi
    phi>
\end{code}

or we can interpret a single file containing a process as follows:

\begin{code}
    $ phi file.pi
\end{code}

\subsection{Language Syntax}

The simplest processes in the language are
\begin{code}
    in(chan,msg)
\end{code}
which receives a message on the channel chan and binds it to the variable msg for subsequent processes

and 
\begin{code}
    out(chan,msg)
\end{code}
which sends the value of variable msg across channel chan.

The most basic channels are the wrappers for stdin, stdout and stderr, all of which have the same names. So, the ubiquitous "Hello World!" program is written in pi-calculus as:
\begin{code}
    out(stdout,"Hello World!")
\end{code}

These can be combined sequentially using \verb!;!, so a more complex example would be:
\begin{code}
    out(stdout,"What is your name?");
    in(stdin,name);
    out(stdout,append("Hello ",name))
\end{code}

We can define our own variables and functions using:
\begin{code}
    let variable = value in process
\end{code}
which binds variable to value locally in process

\begin{code}
    let function(..) = body in process 
\end{code}
which binds the function(..) to be body locally in process

So to rewrite our second example:
\begin{code}
    out(stdout,"What is your name?");
    in(stdin,name);
    let prependHello(a) = append("Hello ",a) in
        let helloName = prependHello(name) in
            out(stdout,helloName)
\end{code}
N.B. Any whitespace above a single space around "in" is ignored, so the above formatting is personal preference

or, if we are in the REPL (or a module file, which we will cover momentarily) we can define variables and functions globally by omitting the "in process"
i.e.
\begin{code}
    let triple(a,b,c) = pair(a,pair(b,c))
\end{code}


\begin{table}[hc!]
    \begin{tabular}{l l}
        \verb!0! & Null process\\
        \verb!P | Q!& Run P $&$ Q concurrently\\
        \verb!P ; Q!& Run P then Q\\
        \verb?!P?& Run infinitely concurrent P\\
        \verb!new x!& Reserve x\\
        \verb!if t1 = t2 then P else Q! &\\
        \verb!let X = M in P!&\\
        \verb!in(chan,msg)! &\\
        \verb!out(chan,msg)! &\\
    \end{tabular}
\end{table} 
