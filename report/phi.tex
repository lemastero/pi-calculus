\section{Evaluation Strategy and Bringing it All Together}
\label{sec:main}
\subsection{Evaluation Strategy Influence}
Having never written an interpreter before, we did some research as to how one might go about doing so. We quickly found Jonathan Tang's Wikibook "Write Yourself a Scheme" \cite{wyas}, which breaks down the construction of an interpreter for the Scheme Lisp dialect. While obviously not entirely translatable to our own project, we undertook this particular tutorial, and found the exercise a very helpful basis for creating an interpreter of our own.

\subsection{Main module}
The main module of our program is the PiCalculus module. This module essentially acts to join together the previously mentioned modules and adds some further functionality. 
There are three main functions of this module
\begin{enumerate}
    \item Handling user input and output
    \item Evaluation of our Data structures including
        \begin{enumerate}
            \item Handling the Environment, which is to say variable assignment
            \item Handling function application
            \item Performing pattern matching
        \end{enumerate}
    \item Handling information received from Channels appropriately
\end{enumerate}

\subsection{User Input and Output}

In this section we describe how input from the user is brought into our evaluation strategy, and then information is handed back to the user. Many of the ideas here are inspired by \cite{wywas}.

\subsubsection{Running the program}
\begin{minted}[linenos,frame=lines]{hs}
main :: IO ()
main = do
        name   <- getProgName
        args   <- getArgs
        case args of
            []  -> runRepl coreBindings
            [x] -> readFile x >>= runProcess coreBindings 
            _   -> do
                    putStrLn           "Use:"
                    putStrLn $ name ++ " -- Enter the REPL"
                    putStrLn $ name ++ " [process] -- Run single process"
\end{minted}

Our main function, which is called every time we type "phi" at the command line. When given one argument, we get the contents of the file with that name and then call runProcess on the returned contents.

\begin{minted}[linenos,frame=lines]{hs}
runProcess :: IO Env -> String -> IO ()
runProcess core expr = core >>= flip evalAndPrint expr
\end{minted}

runProcess accepts a set of core bindings and then calls eval and print on the strin in its second argument

\begin{minted}[linenos,frame=lines]{hs}
evalAndPrint :: Env -> String -> IO ()
evalAndPrint env expr = do
            res <- evalString env expr 
            case res of
                "()"  -> return ()
                _     -> putStrLn res
\end{minted}

evalAndPrint evaluates a string in a given environment. The case clause here is to avoid "()" being printed every time we evaluate a string to Void\footnote{()}

\begin{minted}[linenos,frame=lines]{hs}
evalString :: Env -> String -> IO String
evalString env expr = 
        runIOThrows $
        liftM show $ 
        liftThrows (readProcess expr) >>= eval env
\end{minted}
evalString is best understood if we break it down line by line. In line 5,  liftThrows lifts its argument from ThrowsError into IOThrowsError, so the result of readProcess expr (so the result of parsing the string we pass into readProcess) is lifted. This lifted value is then passed into eval env where it is evaluated in the given environment using eval \ref{sec:eval}.
Once this has been evaluated, we map show over the result of evaluating our parsed expression, and then call runIOThrows on that result, meaning we are now calling runIOThrows on a value of type IOThrowsError String.

\begin{minted}[linenos,frame=lines]{hs}
runIOThrows :: IOThrowsError String -> IO String
runIOThrows action = liftM extractValue 
                     (runExceptT (trapError action))

trapError :: IOThrowsError String -> IOThrowsError String
trapError action = catchE action (return . show)
\end{minted}

runIOThrows first calls trapError on the action passed in, which catches an exception thrown in the action and returns it.Then we call runExceptT which has type

\begin{minted}{hs}
runExceptT :: e m a -> m (Either e a)
\end{minted}

which for us means

\begin{minted}{hs}
runExceptT :: PiError IO String -> IO (Either PiError String)
\end{minted}

Then we lift a call to extractValue to retrieve the value from the Either PiError String
However, because we have already caught any potential exceptions and returned them in the IOThrowsError monad, we will never encounter a Left in this Either, so we are safe to put a call to error in this function. 

\begin{minted}[linenos,frame=lines]{hs}
extractValue :: ThrowsError a -> a 
extractValue (Right v) = v
extractValue (Left  e) = error (show e)
\end{minted}

So, backtracking, this now gives us a value of type IO String, which is exactly what we want. 

If however we are passed no arguments, we enter the Read-Eval-Print Loop, where the only function we have not already met is until_, which simply keeps performing a monadic action until(!) a condition is met

\begin{minted}[linenos,frame=lines]{hs}
runRepl :: IO Env -> IO ()
runRepl core = core >>= until_ quit 
               (readPrompt "phi>") . evalAndPrint
        where
            quit = flip any [":quit",":q"] . (==)
\end{minted}

\subsection{Evaluation of Data structures}
\label{sec:eval}

\begin{minted}[linenos,frame=lines]{hs}
eval :: Env -> PiProcess -> IOThrowsError () 
evalTerm :: Env -> Term -> IOThrowsError Value
evalCond :: Env -> Condition -> IOThrowsError Bool
\end{minted}

\subsubsection{Environment}

\begin{minted}[linenos,frame=lines]{hs}
nullEnv :: IO Env
nullEnv = newIORef Map.empty

getVar :: Env -> String -> IOThrowsError Value 
getVar envRef var = do env <- liftIO $ readIORef envRef
                       maybe (throwE $ UnboundVar "Getting an unbound variable" var)
                             return
                             (Map.lookup var env)
                           
defineVar :: Env -> String -> Value -> IOThrowsError ()
defineVar envRef var val = liftIO $ do
         env      <- readIORef envRef
         writeIORef envRef $ Map.insert var val env

bindVars :: Env -> [(String , Value)] -> IO Env
bindVars envRef bindings = do
                env <- readIORef envRef
                newIORef $ Map.union (Map.fromList bindings) env

coreBindings :: IO Env
coreBindings = do
                n <- nullEnv 
                e1 <- bindVars n (map (second PrimitiveFunc) primitives) 
                e2 <- bindVars e1 (map (second Chan) nativeChannels)
                net <- newDummyChan
                bindVars e2 [(counterRef, Term $ TNum lowestPort),
                             ("localnet"     , Chan net)]
                where 
                    lowestPort = 2^(15::Integer) + 2^(14::Integer)
\end{minted}


\subsubsection{Function Application}

\begin{minted}[linenos,frame=lines]{hs}
apply :: Value -> [Value] -> IOThrowsError Value 
apply (PrimitiveFunc fun) args = do
                        ts <- extractTerms args
                        res <- liftThrows $ fun ts
                        return $ Term res
apply (Func parms bdy closre) args =
    if num parms /= num args 
        then throwE $ NumArgs "user-defined" (num parms) args
        else do
             clos <- liftIO (bindVars closre $ zip parms args)
             case bdy of
                Term t -> evalTerm clos t
                Proc p -> eval clos p >> return bdy
                _      -> throwE $ Default "this function makes no sense"
    where
        num = toInteger . length
apply e _ = throwE $ NotFunction "expecting a function found" (show e)
\end{minted}

\subsubsection{Pattern Matching}

\begin{minted}[linenos,frame=lines]{hs}
eval env (Let t1 (Term t2) (Just p)) = do
                val <- evalTerm env t2 
                case val of 
                    Term term -> do
                        bindings <- liftThrows $ match t1 term
                        newEnv <- liftIO $ bindVars env bindings
                        eval newEnv p
                    _         -> throwE $ Default "Can only pattern match against Terms"
eval env (Let t1 (Term t2) Nothing) = do 
                val <- evalTerm env t2 
                case val of 
                    Term term -> do
                        bindings <- liftThrows $ match t1 term
                        mapM_ (uncurry (defineVar env)) bindings
                        _         -> throwE (Default "Can only pattern match against Terms")
\end{minted}

\subsection{Data from Channels}

\begin{minted}[linenos,frame=lines]{hs}
sendOut :: Channel -> Value -> IOThrowsError () 
sendOut chan v@(Chan c) = if serialisable c
                        then liftIO $ send chan $ show v
                        else throwE $ Default "Channel not serialisable" 
sendOut chan val = liftIO $ send chan $ show val


receiveIn :: Channel -> Maybe Type -> IOThrowsError Term
receiveIn chan t = do
        str <- liftIO $ receive chan
        case t of
                    Just HttpRequest  -> makeHttpRequest str
                    Just HttpResponse -> makeHttpResponse str
                    _                 -> liftThrows $ readTerm str

makeHttpRequest :: String -> IOThrowsError Term
makeHttpRequest str = do
    let ls = lines str
    (r,u, hs) <- case parseRequestHead ls of
        Left _     -> throwE $ Default "Malformed HTTP Request"
        Right (r,u,h) -> return (r,u,h)
    return $ TData $ Req $ Request u r hs (msgBody ls)

makeHttpResponse :: String -> IOThrowsError Term
makeHttpResponse str = do
    let ls = lines str
    (c, r, hs) <- case parseResponseHead ls of
        Left _     -> throwE $ Default "Malformed HTTP Request"
        Right (c,r,h) -> return (c,r,h)
    return $ TData $ Resp (Response c r hs (msgBody ls))

msgBody :: [String] -> String
msgBody = unlines . dropWhile (/= crlf)
    where
        crlf = "\r"
\end{minted}


